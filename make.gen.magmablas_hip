# File: Make.gen.magmablas_hip
#   @author Cade Brown
#
# Automatically generates `magmablas_hip` from `magmablas`
# (and will regenerate it if any files change)
#
#
# Major conversions:
# .h -> .h
# .cuh -> .hip.hpp
# .cu -> .cpp
# *_config/ -> *_config/
#
# These are 'hipified', and processed to replace the old CUDA-specific names/files
# Export the path to `hipify-perl` as `HIPIFY=DIR/hipify-perl`, or keep it in your path
#
#
#

# utility functions
HIPIFY            ?= tools/hipify-perl

# TODO: Distribute a `hipify` script with MAGMA

ifeq ($(HIPIFY),)
$(error Could not find `hipify` please run like `HIPIFY=... make magmablas_hip`)
endif


#*- input files -*#

magmablas_src_cpp = $(wildcard magmablas/*.cpp)
magmablas_src_cu  = $(wildcard magmablas/*.cu)
magmablas_src_cuh = $(wildcard magmablas/*.cuh)
magmablas_src_h   = $(wildcard magmablas/*.h)
# Makefiles
magmablas_src_mk  = $(wildcard magmablas/Makefile*)
# config directories (like gemm_config/)
magmablas_src_cfg = $(wildcard magmablas/*_config)


#*- output files -*#

# C++ files stay as C++
magmablas_hip_cpp = $(patsubst magmablas/%.cpp,magmablas_hip/%.cpp,$(magmablas_src_cpp))
# the result of any CUDA file is a `.hip.cpp`, so we know which ones were converted (the `.hip` isn't "neccessary" per se, but is nice to see which may contain device code/kernels)
magmablas_hip_cu  = $(patsubst magmablas/%.cu,magmablas_hip/%.hip.cpp,$(magmablas_src_cu))
# the result of any CUDA header is a `.hip.hpp`, which again, is not necessary, but is nice to be able to quickly tell whether code is device+host or host only
magmablas_hip_cuh = $(patsubst magmablas/%.cuh,magmablas_hip/%.hip.hpp,$(magmablas_src_cuh))
# normal header files are still normal header files
magmablas_hip_h   = $(patsubst magmablas/%.h,magmablas_hip/%.h,$(magmablas_src_h))
# makefiles are the same essentially
magmablas_hip_mk  = $(patsubst magmablas/Makefil%,magmablas_hip/Makefil%,$(magmablas_src_mk)) 
# output configs are the same
magmablas_hip_cfg = $(patsubst magmablas/%_config,magmablas_hip/%_config,$(magmablas_src_cfg))


#*- build rules *-#

# just build the fake target
all: magmablas_hip/.cache

# we create a fake target for the directory so it is generated correctly
.PHONY: clean magmablas_hip/.cache

# it will depend on the directory, and all sources to be built
magmablas_hip/.cache: magmablas_hip $(magmablas_hip_cpp) $(magmablas_hip_cu) $(magmablas_hip_cuh) $(magmablas_hip_h) $(magmablas_hip_mk) $(magmablas_hip_cfg)

# creates the directory
magmablas_hip:
	mkdir -p $@

# since all files are stored in magmablas_hip/, this rule removes all changes the makefile could have made
clean:
	rm -rf magmablas_hip/

# converts .cpp <- .cpp
magmablas_hip/%.cpp: magmablas/%.cpp
	$(HIPIFY) $< > $@
	@sed -i -e "s/.cuh/.hip.hpp/g" $@

# converts .hip.cpp <- .cu
magmablas_hip/%.hip.cpp: magmablas/%.cu
	$(HIPIFY) $< > $@
	@sed -i -e "s/.cuh/.hip.hpp/g" $@

# converts .hip.hpp <- .cuh
magmablas_hip/%.hip.hpp: magmablas/%.cuh
	$(HIPIFY) $< > $@
	@sed -i -e "s/.cuh/.hip.hpp/g" $@


# converts .h <- .h 
# I've looked through these, they don't require any special transformations
# so, just copy them
magmablas_hip/%.h: magmablas/%.h
	cp $< $@
	sed -i -e "s/.cuh/.hip.hpp/g" $@


# converts *_config <- *_config
# these are things like gemm_configs, so are architecture agnostic
# so, just copy them
magmablas_hip/%_config: magmablas/%_config
	cp -rf $< $@

# little hack with the rule so it will match `Makefile` and `Makefile.*`
# we need to also sed through and replace some header rules with our above transforms
magmablas_hip/Makefil%: magmablas/Makefil%
	cp $< $@
	@sed -i -e "s/:=  *magmablas/:= magmablas_hip/g" $@
	@sed -i -e "s/.cuh/.hip.hpp/g" $@
	@sed -i -e "s/.cu/.hip.cpp/g" $@


